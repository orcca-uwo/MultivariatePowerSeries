##ENCODING ISO-8859-1
##PROCEDURE(help,nospec,label="MultivariatePowerSeries/PowerSeries",versionnew="{XENOMORPH}",versionupdated="{YETI}") MultivariatePowerSeries[PowerSeries]
##TITLE(halfline="create a power series")
##    MultivariatePowerSeries[PowerSeries]
##ALIAS PowerSeries, MultivariatePowerSeries:-PowerSeries, MultivariatePowerSeries
##AUTHOR Ali Asadi masadi4@uwo.ca, Alex Brandt abrandt5@uwo.ca, Marc Moreno Maza moreno@csd.uwo.ca
##
##CALLINGSEQUENCE
##- PowerSeries('p')
##- PowerSeries('r')
##- PowerSeries('e')
##- PowerSeries('f', 'opts')
##- PowerSeries('u')
##- PowerSeries('ps')
##
##PARAMETERS
##- 'p' : polynomial
##-(versionnew="{YETI}") 'r' : rational function
##-(versionnew="{YETI}") 'e' : arbitrary expression
##- 'f' : procedure
##- 'opts' : (optional) equation(s) of the form 'option' = 'value'
##  where 'option' is one of 'analytic', 'check', 'variables', or 'expand'; at least one of
##  'analytic' and 'variables' must be specified
##- 'u' : univariate polynomial over power series
##- 'ps' : power series generated by this package
##
##DESCRIPTION
##- The calling sequence ~PowerSeries(p)~, where 'p' is a polynomial,
##  creates a power series representing this polynomial. Concretely, the homogeneous part of degree
##  'i' of this power series
##  is equal to the sum of all terms of degree 'i' in 'p'.  In particular,
##  the homogeneous part of degree 'i' of that power series is zero
##  whenever 'i' is greater than the degree of 'p'.
##  Note that the polynomial 'p' can be a complex constant; in that case, 'p' is regarded as a polynomial
##  of degree zero.
##- The calling sequence ~PowerSeries(r)~, where 'r' is a rational function, computes power series
##  for the numerator and denominator of 'r' as above, then computes the quotient of the two. This
##  is possible only if the denominator is invertible, that is, it has a nonzero constant term.
##- The calling sequence ~PowerSeries(e)~, where 'e' is an expression that is not a rational
##  function, uses the "series" command to attempt to express 'e' as a power series at the origin in
##  each of the variables occurring in 'e'.
##- The calling sequence ~PowerSeries(f, opts)~, where 'f' is a procedure,
##  creates a power series whose homogeneous part of degree 'i'
##  is equal to the value of the function call ~f(i)~. This assumes
##  that the procedure 'f' takes a non-negative integer as input and returns
##  a polynomial as output.
##-- If the optional argument 'analytic=g'
##  is passed, where 'g' is an algebraic expression, then the power series is assumed to
##  be equal to 'g' in a neighborhood of the origin. There is no verification of this
##  assumption.
##-- If the optional argument 'variables=s' is passed, where 's' is a set of variable names, then
##  the power series is a power series in the given variables. If this option is omitted, then the
##  'analytic' option must be specified, and Maple determines the set of variables from that
##  option. Either this option or the 'analytic' option must be specified.
##-- By default, every time 'f' is invoked, its result
##  is verified to be a polynomial of the expected homogeneous degree in the given variables. If you know this is not necessary,
##  you can include the optional argument 'check=false' to disable these checks for greater efficiency.
##-- By default, every time 'f' is invoked, its result
##  is expanded. If you know that the value returned by 'f' will always be expanded, you can include the optional argument
##  'expand=false' to disable these calls for greater efficiency.
##- The calling sequence ~PowerSeries(u)~, where 'u' is a univariate polynomial
##  over power series, returns 'u' as a power series. To be precise, if _v_ is the main variable of 'u'
##  and its coefficients are power series
##  with variables in the set of variables _x_, let _y_ be the union of _x_ with _v_. Then
##  the power series returned by
##  ~PowerSeries(u)~ is the image of 'u' in the power series ring with variables in
##  _y_. This image is obtained 
##  by the natural homomorphism mapping the univariate polynomial ring _R[v]_
##  into the univariate power series ring __"R &lobrk; v &robrk;"__, where _R_ is the ring of power
##  series in variables in _x_.
##- The calling sequence ~PowerSeries(ps)~, where 'ps' is a power series, returns a copy of 'ps'.
##- The implementation of power series and univariate polynomials over
##  power series relies on lazy evaluation (also known as calls-by-need). For details, see
##  the "MultivariatePowerSeries" help page.
##
##INCLUDE assignment_warning.mi
##
##EXAMPLES
##> with(MultivariatePowerSeries):
##-(lead=indent) Create a power series from a polynomial, determine its inverse, and find its
##  truncation to homogeneous degree 5.
##> a := PowerSeries(1 + x + x*y + x^2);
##<(verification="type") object
##> b := Inverse(a);
##<(verification="type") object
##> Truncate(b, 5);
##<(verification="type") polynom
##>(nohelp) ldegree(expand(Truncate(b, 5) * (1 + x + x*y + x^2)) - 1);
##<(verification="verify,greater_than") 5
##-(lead=indent) We can also compute _b_ by specifying the rational function that is the inverse of
##  the polynomial used to define _a_.
##> b := PowerSeries(1/(1 + x + x*y + x^2));
##<(verification="type") object
##> Truncate(b, 5);
##<(verification="type") polynom
##>(nohelp) ldegree(expand(Truncate(b, 5) * (1 + x + x*y + x^2)) - 1);
##<(verification="verify,greater_than") 5
##-(lead=indent) Create a power series for the expression _exp(x)_.
##> b := PowerSeries(exp(x));
##<(verification="type") object
##> Truncate(b, 5);
##< 1 + x + x^2/2 + x^3/6 + x^4/24 + x^5/120
##-(lead=indent) Create a power series for an elliptic integral of the third kind.
##> b := PowerSeries(EllipticPi(z, nu, k));
##<(verification="type") object
##> Truncate(b, 5);
##< z+1/6*z^3+1/3*z^3*nu+3/40*z^5+1/6*z^3*k^2
##-(lead=indent) Create a power series from a procedure and find its truncation to homogeneous
##  degree 3.
##> bproc := proc(d) local s; s := 2*x + y; return expand(s^d); end proc:
##> b := PowerSeries(bproc, variables = {x, y});
##<(verification="type") object
##> Truncate(b, 3);
##< expand(add((2*x+y)^i, i=0..3))
##-(lead=indent) Create a power series from an anonymous function, specifying the analytic form of
##  that power series. Find the truncations to homogeneous degrees 5 and 10.
##> c := PowerSeries(d -> (x^d/d!), analytic=exp(x));
##<(verification="type") object
##> Truncate(c, 5);
##< convert(series(exp(x), x=0, 6), polynom)
##> Truncate(c, 10);
##< convert(series(exp(x), x=0, 11), polynom)
##-(lead=indent) Create a power series from a univariate polynomial over power series.
##> f := UnivariatePolynomialOverPowerSeries([PowerSeries(1), PowerSeries(x), PowerSeries(y),
##  GeometricSeries([x,y])], z):
##<(verification="type") object
##- The truncation to homogeneous degree 2 is given by truncating each coefficient to that degree,
##  ignoring _f_'s main variable, _z_.
##> Truncate(f, 2);
##<(verification="verify,expand") 1 + x*z + y*z^2 + (1 + x + y + x^2 + 2*x*y + y^2)*z^3
##- If we convert _f_ to a power series, its truncation is defined by considering the homogeneous
##  degree in all variables, including _z_.
##> d := PowerSeries(f);
##<(verification="type") object
##> Truncate(d, 3);
##< 1 + x*z + y*z^2 + z^3
##-(lead=indent) Copy a power series.
##> e := PowerSeries(d);
##<(verification="type") object
##>(nohelp) Truncate(d-e, 50);
##< 0
##
##SEEALSO
##- "MultivariatePowerSeries"
##- "GeometricSeries"
##- "SumOfAllMonomials"
##- "Inverse"
##- "Truncate"
##- "UnivariatePolynomialOverPowerSeries"
## 
##XREFMAP
##- MultivariatePowerSeries : Help:MultivariatePowerSeries
##- GeometricSeries : Help:MultivariatePowerSeries[GeometricSeries]
##- SumOfAllMonomials : Help:MultivariatePowerSeries[SumOfAllMonomials]
##- Inverse :  Help:MultivariatePowerSeries[Inverse]
##- Truncate : Help:MultivariatePowerSeries[Truncate]
##- UnivariatePolynomialOverPowerSeries : Help:MultivariatePowerSeries[UnivariatePolynomialOverPowerSeries]
