##PROCEDURE(help,nospec,label="MultivariatePowerSeries/Substitute",versionnew="{YETI}") MultivariatePowerSeries[Substitute]
##TITLE(halfline="substitute values into a power series") MultivariatePowerSeries[Substitute]
##
##CALLINGSEQUENCE
##- Substitute('x' = 's', 'p')
##- Substitute('ls', 'p')
##
##PARAMETERS
##- 'x' : variable
##- 's' : polynomial or power series generated by this package
##- 'p' : power series generated by this package
##- 'ls' : list or set of substitutions, each of the form 'x' = 's'
##
##DESCRIPTION
##- The command ~Substitute(x = s, p)~ computes the result of substituting the expression 's' for
##  the variable 'x' in the power series 'p'. The expression 's' can be a polynomial or a power
##  series generated by this package.
##- The calling sequence ~Substitute(ls, p)~, where 'ls' is a list or set of equations of the form
##  ~x = s~ above, applies all of the given substitutions simultaneously. More precisely, if 'ls'
##  contains the equations ~x[i] = s[i]~ where 'i' runs from 1 to 'n', then it returns an answer
##  equivalent to what would be obtained from the following process:
##-- For each variable 'v[i,j]' occurring in 's[i]', replace it with a variable 'u[i,j]' that
##   doesn't occur anywhere else (it should also not occur as 'u[i,j]' in previous such
##   replacements). Call the result 't[i]'.
##-- Perform the substitutions ~x[i] = t[i]~ in any order. Call the result 'q'.
##-- Replace each 'u[i, j]' in 'q' with the original 'v[i, j]'.
##- An error is thrown if the same variable 'x' occurs more than once as a left hand side in
##  'ls'.
##- If 's' is not a unit, that is, if its constant coefficient is zero, then the result of the
##  substitution is easily defined by just substituting one power series into another; one need
##  consider only finitely many terms to find any homogeneous component of the result. However, if
##  's' is a unit, then the result of the substitution is a priori not well-defined. In these cases,
##  Maple uses the "analytic expression" specified for 'p' in a computation that gives a result that
##  is correct in a formal sense. If the analytic expression for 'p' is not specified, Maple throws
##  an error. If a list or set of substitutions is specified and some of the right hand sides 's'
##  are unit power series, then this computation only works if 'p' and at least all but one of these
##  unit power series have their analytic expression specified.
##
##INCLUDE assignment_warning.mi
##
#
# TODO: write a paper about how this works (for unit power series) and reference it here.
#
##EXAMPLES
##> with(MultivariatePowerSeries):
##- Consider the simplest case: polynomial substitution, with polynomials that are not units (that
##  is, their constant coefficient is zero).
##> p1 := x^2 + y*z + z;
##> p2 := y^2 + z*x + x;
##> p3 := z^2 + x*y + y;
##> ps1, ps2, ps3 := seq(PowerSeries(p), p in [p1, p2, p3]);
##> result := Substitute({x = ps1, y = ps2}, ps3);
##<(verification="type") object
##- We can obtain the same result by substituting the actual polynomials in, rather than the
##  polynomials converted to power series.
##> ApproximatelyEqual(result, Substitute({x = p1, y = p2}, ps3), 4);
##< true
##- We can verify that the result is correct by comparing with the result of doing the substitution
##  entirely in the domain of polynomials.
##> expand(Truncate(result, 4) - subs({x = p1, y = p2}, p3));
##< 0
##- We can do the same with unit power series.
##> q1, q2, q3 := seq(p + 1, p in [p1, p2, p3]);
##> qs1, qs2, qs3 := seq(PowerSeries(q), q in [q1, q2, q3]);
##> qresult := Substitute({x = qs1, y = qs2}, qs3);
##<(verification="type") object
##> ApproximatelyEqual(qresult, Substitute({x = q1, y = q2}, qs3), 4);
##< true
##> expand(Truncate(qresult, 4) - subs({x = q1, y = q2}, q3));
##< 0
##
##- The following example shows that simple arithmetic does not suffice to do the substitution
##  operation: the input power series has rational coefficients, but the result has transcendental
##  coefficients. We compute the power series for _exp(exp(x))_ from that of _exp(x)_.
##> exp_x := PowerSeries(d -> x^d/d!, analytic=exp(x));
##> result := Substitute(x = exp_x, exp_x);
##<(verification="type") object
##> Truncate(result, 4);
##< exp(1) + exp(1)*x + exp(1)*x^2 + 5/6*exp(1)*x^3 + 5/8*exp(1)*x^4
##> series(exp(exp(x)), x=0, 5);
##>(nohelp) Truncate(result, 4) - convert(series(exp(exp(x)), x=0, 5), ':-polynom');
##< 0
##
##- To underscore the necessity to have analytic expressions in the presence of unit power series,
##  consider the following example, where we omit the analytic expression for the series of
##  _exp(y)_. 
##> exp_y_no_a := PowerSeries(d -> y^d/d!, variables={y});
##- We want to substitute _exp(x)_ for _ex_ and _exp(y)_ for _ey_ in _ex + ey_. If we first
##  substitute _exp(y)_ for _ey_, then the resulting power series doesn't know its analytic
##  expression, and we obtain an error when we substitute _exp(x)_ for _x_.
##> base := PowerSeries(ex + ey);
##> step1 := Substitute(ey = exp_y_no_a, base);
##> step2 := Substitute(ex = exp_x, step1);
##<(verification="testerror") "substituting a unit power series into a power series with undefined analytic expression"
##- In the other order, the process does work.
##> alt_step1 := Substitute(ex = exp_x, base);
##> alt_step2 := Substitute(ey = exp_y_no_a, alt_step1);
##- This is the order chosen by Maple when the two substitutions are given simultaneously.
##> result := Substitute({ex = exp_x, ey = exp_y_no_a}, base);
##> ApproximatelyEqual(result, alt_step2, 4);
##< true
##
##SEEALSO
##- "subs"
##- "eval"
##- "MultivariatePowerSeries[PowerSeries]"
##
##XREFMAP
##- "analytic expression" : Help:MultivariatePowerSeries[GetAnalyticExpression]
##
