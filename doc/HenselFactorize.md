##ENCODING ISO-8859-1
##PROCEDURE(help,nospec,label="MultivariatePowerSeries/HenselFactorize",versionnew="{XENOMORPH}") MultivariatePowerSeries[HenselFactorize]
##TITLE(halfline="Factorize a univariate polynomial over power series")
##    MultivariatePowerSeries[HenselFactorize]
##ALIAS HenselFactorize, MultivariatePowerSeries:-HenselFactorize, MultivariatePowerSeries
##AUTHOR Ali Asadi masadi4@uwo.ca, Alex Brandt abrandt5@uwo.ca, Marc Moreno Maza moreno@csd.uwo.ca
##
##CALLINGSEQUENCE
##- HenselFactorize('u')
##- HenselFactorize('u', 'lcopt')
##
##PARAMETERS
##- 'u' : univariate polynomial over power series generated by this package
##- 'lcopt' : (optional) equation of the form ~returnleadingcoefficient = r~, where
##  `returnleadingcoefficient` is a literal keyword and 'r' is one of the values `true`, `false`,
##  and `automatic`
##
##DESCRIPTION
##- The command ~HenselFactorize(u)~ factorizes 'u' over the ring of power series
##  of the coefficients of 'u' and returns the factors as a list.
##  The factors may not be linear, since 'u' is not factored over the field of
##  Puiseux series of the coefficients of 'u'.
##- There are two requirements on 'u' for 'HenselFactorize' to succeed in factorizing 'u'. If either
##  of these requirements is not met, an error is signaled.
##-- The leading coefficient 'pn' of 'u' (the power series that is the coefficient of the highest
##   power of the main variable) must be invertible. That is, its constant term (the homogeneous
##   part of 'pn' of degree 0) needs to be nonzero.
##-- Furthermore, for each power series 'p' that is a coefficient of 'u', the constant coefficient
##   of 'p' (that is, the homogeneous part of degree 0) divided by the constant coefficient of 'pn'
##   needs to be an algebraic number. That is, the coefficient needs to be of type "algnum", either
##   immediately or after applying "convert/RootOf". These coefficients are exactly the coefficients
##   of the polynomial 'f' returned by ~EvaluateAtOrigin(v)~ in the algorithm description below.
##- The command ~HenselFactorize(u)~ proceeds as follows.
##-- For the first step, let 'pn' be the leading coefficient of 'u' (the power series that is the
##   coefficient of the highest power of the main variable). Maple verifies if its "analytic
##   expression" is known. If it is not known, or known to be different from 1, then we multiply 'u'
##   by the inverse of 'pn'; let us call the result 'v'. Otherwise (if 'pn' is known to be equal to
##   1), 'v' is defined to be equal to 'u'. See also the discussion of the
##   `returnleadingcoefficient` option below.
##-- In the second step, the polynomial 'f' returned by ~EvaluateAtOrigin(v)~ is factored over the
##   algebraic numbers.
##-- Finally, each of the factors of 'f' is lifted in turn, by repeated calls to the commands
##   "TaylorShift" and "WeierstrassPreparation".
##- The command ~HenselFactorize(u)~ is based on lazy evaluation techniques.
##  To be precise, this command returns as soon as the factors of 'f' are
##  computed and all coefficients (which are
##  power series) of the factors of 'u' are initialized (that is, once their
##  generators are determined).
##- Since it is really 'v' that is factored in the second and third steps of the algorithm below,
##  and 'v' and 'u' differ by a factor of 'pn' (the leading coefficient of 'u'), it is necessary to
##  include a factor corresponding to 'pn' in order to obtain factors that multiply together to
##  'u'. The `returnleadingcoefficient` option determines whether 'pn', investigated and potentially
##  used in the first step of the algorithm, is returned with the other factors. In all cases, if
##  'pn' is returned, it is converted to a univariate polynomial over power series with the same
##  main variable as 'u' in order to match the type of the other factors; of necessity, it is a
##  constant polynomial, because it does not depend on the main variable (it is, after all, a
##  coefficient of the main variable in 'u').
##-- If the option ~returnleadingcoefficient = true~ is included, then 'pn' is always returned as
##   the first entry in the resulting list of factors, even if it is equal to 1.
##-- If the option ~returnleadingcoefficient = false~ is included, then 'pn' is always omitted from
##   the resulting list of factors, even if it is different from 1. In this case, the resulting list
##   of factors will contain only univariate polynomials over power series of positive degree in the
##   main variable.
##-- By default (or if this behaviour is selected explicitly by including the option
##   ~returnleadingcoefficient = automatic~), 'pn' is returned as the first entry of the resulting
##   list of factors *only* if it is *not known* to be equal to 1, and omitted otherwise.
##
##INCLUDE assignment_warning.mi
##
##EXAMPLES
##> with(MultivariatePowerSeries):
##- We define a univariate polynomial over power series, _f_, and determine its Hensel
##  factorization. It factors into linear factors.
##> f := UnivariatePolynomialOverPowerSeries((z - 1)*(z - 2)*(z - 3) + x*(z^2 + z), z):
##<(verification="type") object
##> F := HenselFactorize(f);
##<(verification="type") [object, object, object]
##- We can see more terms of the factors as follows.
##> map(print, map(UpdatePrecision, F, 5)):
##- We define a new univariate polynomial over power series, _g_. Its Hensel factorization has a
##  linear and a quadratic factor.
##> g := UnivariatePolynomialOverPowerSeries(y^2 + x^2 + (y + 1)*z^2 + z^3, z):
##<(verification="type") object
##> G := HenselFactorize(g);
##<(verification="type") [object, object]
##> map(print, map(UpdatePrecision, G, 5)):
##- The two examples above have leading coefficients that are known to be equal to 1. The case below
##  has a leading coefficient equal to _exp(x)_ (an invertible power series). Its Hensel
##  factorization has a linear and a quadratic factor, and the leading coefficient is also included
##  as a factor.
##> a := PowerSeries(d -> x^d/d!, analytic = exp(x));
##<(verification="type") object
##> b := 2 * SumOfAllMonomials([x, y]);
##<(verification="type") object
##> c := PowerSeries(d -> ifelse(d :: even, (-1)^(d/2) * x^d/d!, 0), analytic = cos(x));
##<(verification="type") object
##> d := PowerSeries(d -> ifelse(d :: odd, (-1)^((d-1)/2) * x^d/d!, 0), analytic = sin(x));
##<(verification="type") object
##> h := UnivariatePolynomialOverPowerSeries([d, c, b, a], z);
##<(verification="type") object
##> H := HenselFactorize(h);
##<(verification="type") [object, object, object]
##> map(print, map(UpdatePrecision, H, 5)):
##- The first entry of the factorization is _a_, the leading coefficient of _h_. It is represented
##  as a trivial univariate polynomial over power series.
##> GetCoefficient(H[1], 0);
##<(verification="type") object
##>(nohelp) evalb(GetCoefficient(H[1], 0) = a);
##< true
##
##SEEALSO
##- "UnivariatePolynomialOverPowerSeries"
##- "TaylorShift"
##- "WeierstrassPreparation"
##- "EvaluateAtOrigin"
##- "UpdatePrecision"
##
##REFERENCES
##-(lead=indent) Alexander Brandt, Mahsa Kazemi, Marc Moreno Maza
##  \"Power Series Arithmetic with the BPAS Library.\"
##  **Computer Algebra in Scientific Computing (CASC)**, **Lecture Notes in Computer Science - 12291**, (2020): 108-128.
##-(lead=indent) Mohammadali Asadi, Alexander Brandt, Mahsa Kazemi, Marc Moreno Maza, and Erik Postma: 
## \" Multivariate Power Series in Maple.\" **Maple Conference 2020, Waterloo, Ontario, Canada, November 2-6, 2020**,
## **Communications in Computer and Information Science (CCIS) series - Springer 2020** (submitted).
##
##XREFMAP
##- UnivariatePolynomialOverPowerSeries : Help:MultivariatePowerSeries[UnivariatePolynomialOverPowerSeries]
##- TaylorShift : Help:MultivariatePowerSeries[TaylorShift]
##- WeierstrassPreparation : Help:MultivariatePowerSeries[WeierstrassPreparation]
##- EvaluateAtOrigin : Help:MultivariatePowerSeries[EvaluateAtOrigin]
##- UpdatePrecision : Help:MultivariatePowerSeries[UpdatePrecision]
##- algnum : Help:type/algnum
##- convert/RootOf : Help:convert/RootOf
##- "analytic expression" : Help:MultivariatePowerSeries[GetAnalyticExpression]
