##ENCODING ISO-8859-1
##PROCEDURE(testlimit=300, help,nospec,label="MultivariatePowerSeries/ExtendedHenselConstruction",versionnew="{ZONKEY}") MultivariatePowerSeries[ExtendedHenselConstruction]
##TITLE(halfline="factorize a univariate polynomial over power series")
##    MultivariatePowerSeries[ExtendedHenselConstruction]
##ALIAS ExtendedHenselConstruction, MultivariatePowerSeries:-ExtendedHenselConstruction, MultivariatePowerSeries
##AUTHOR Juan Gonzalez Trochez jgonza55@uwo.ca, Marc Moreno Maza moreno@csd.uwo.ca, Erik Postma
##
##CALLINGSEQUENCE
##- ExtendedHenselConstruction('u')
##- ExtendedHenselConstruction('u', 'hb', 't', 'opt1', 'opt2')
##
##PARAMETERS
##- 'u' : univariate square-free polynomial with power series coefficients generated by this package
##- 'hb' : (optional) non-negative integer
##- 't' : (optional) variable name
##- opt1 : (optional) equation of the form `returnleadingcoefficient` = `optval`, where `optval` is `automatic`, `true`, or `false`
##- opt2 : (optional) equation of the form `output` = `optval`, where `optval` is `factorization`, or `changeofvariables`
##
##DESCRIPTION
##SUBSECTION(collapsed=false) Univariate case
##- The command ~ExtendedHenselConstruction(u)~ factorizes 'u' over the field of univariate Puiseux series and returns the factors as a list of linear polynomials, or issues an error if this is not possible.
##- Note that `u` is a univariate polynomial with univariate power series coefficients. Let 'x' be the variable of `u` and 'y' be the variable of the coefficients of 'u'. 
##	The command ~ExtendedHenselConstruction(u)~ proceeds as follows.
##-- First, Maple checks whether 'u' is approximately square-free or not. In the latter case, an error is thrown.
##	 If the "analytic expression" of 'u' is known to be of type polynomial, then this expression is used to
##	 compute the discriminant of 'u'. Otherwise, we use a bound 'b' to compute an approximation of the 
##	 discriminant of 'u' up to that bound. In the case where this approximated discriminant is 
##	zero, an error is issued. It is possible to increase the bound 'b' used for this computation,
##	 for more details, see the discussion below. 
##-- Secondly, let 'pn' be the leading coefficient of 'u' (the power series that is the
##   coefficient of the highest power, say 'n', of 'x'). Maple verifies whether its "analytic
##   expression" is known. If it is not known, or known to be different from 1 (see explanation bellow), 
##	 then an appropriate transformation 'T' is applied to make 'u' monic; let us call the resulting polynomial 'v'. 
##	 Otherwise (if 'pn' is known to be equal to
##   1), 'v' is defined to be equal to 'u'. 
##-- Note that if the "analytic expression" of
##	 'u' is "undefined",then the "ApproximatelyZero" function is called, with value 'b',
##	 to check if 'pn' is approximately zero or not. If "ApproximatelyZero" returns true,
##	 then an error is returned. It is possible to rerun the ~ExtendedHenselConstruction(u, b)~ command
##	 with a greater value for 'b'. See also the discussion of the
##   `returnleadingcoefficient` option below.
##-- Next, the Newton polynomial of 'v' is computed. When the "analytic expression" of 'v' is non-polynomial, we
##   truncate 'v' up to degree 'b' and try to compute its Newton polynomial. If this process fails, then an error
##   is issued. It is possible to rerun the command with a greater value of 'b', ~ExtendedHenselConstruction(u, b)~. 
##-- To follow, the Newton polynomial is made univariate by evaluating  `y`  at '1', that is letting `y=1`. 
##	 Afterwards, the evaluated Newton polynomial is factored; 
##	 its factors are called the initial factors.  To compute the approximate value of each factor of 'v'
##	 a Hensel lifting strategy is applied; this starts by computing the so-called Yun-Moses polynomials.  
##-- Note that if one or more of the lifted factors is not linear, then the factorization
##	 process is applied to each of these non-linear factors after applying
##	 an appropriate change of variable. See Sasaki's paper.
##	 If the `returnleadingcoefficient` option is present (see below), then the
##	 coefficient 'pn' is added to the list containing the output of Extended HenselFactorize.
##-- Finally, if necessary ('pn' different than 1), the inverse of the transform 'T' is applied 
##	 to each of the output factors.
##ENDSUBSECTION
##SUBSECTION(collapsed=false) Multivariate case 
##- The command ~ExtendedHenselConstruction(u, t)~ factorizes 'u' w.r.t. total degree, using the total
##  degree variable `t`, and returning the factors as a list of linear polynomials, 
##	or issues an error if this is not possible.
##- Note that 'u' is a univariate polynomial with multivariate power series coefficients. 
##  Let 'x' be the variable of `u` and let x_1,...,x_m' be the variables occuring in the coefficients of `u`.
##  We assume that `m` is at least `2`.
##	Then, the change of variables 'x_1=t*x_1(0), ..., x_m=t*x_m(0)' is applied, where 't' is the input variable name. 
##	Maple now sees the coefficients of 'u' as univariate power series in the variable 't' and 'x_1,...,x_m' are seen as
##	constants. Thus, the same process as before can now be applied.
##-	For this call, the ~ExtendedHenselConstruction~ algorithm returns a list of polynomials in the variables 'x' and 't'.
##	The variables 'x_1(0),...,x_m(0)' are still considered as constants. 
##-  If the option ~output = changeofvariables~ is included, then the change of variable
##	 't=1, x_1(0)=x_1, ..., x_m(0)=x_m' is also returned together with the factorization of 'u'. By default
##	 only the factorization of 'u' is returned.
##ENDSUBSECTION
##SUBSECTION(collapsed=false) Optional values 
##- If the argument 'hb' is given, its value is used for the bound 'b'.
##  Otherwise, the global default for bound 'b' (10) is used (see also "SetHenselBound").
##	The bound 'b' is used in three cases: 
##-- when computing an approximated discriminant of a polynomial with non-polynomial "analytic expression";
##-- when the "ApproximatelyZero" algorithm is called;
##-- when the Newton polynomial of 'u' is computed, and at least one of its 
##	 coefficients has a non-polynomial "analytic expression". 
##- Since it is really 'v' that is factored in the second and third steps of the algorithm above,
##  and 'v' and 'u' differ by a factor of 'pn' (the leading coefficient of 'u'), it is necessary to
##  include a factor corresponding to 'pn' in order to obtain factors that multiply together to
##  'u'. The `returnleadingcoefficient` option determines whether 'pn', investigated and potentially
##  used in the first step of the algorithm, is returned with the other factors. In all cases, if
##  'pn' is returned, it is converted to a univariate polynomial over power series with
##  main variable 'x' in order to match the type of the other factors; out of necessity, it is a
##  constant polynomial, because it does not depend on 'x' (it is, after all, a
##  coefficient of 'x').
##-- If the option ~returnleadingcoefficient = true~ is included, then 'pn' is always returned as
##   the first entry in the resulting list of factors, even if it is equal to 1.
##-- If the option ~returnleadingcoefficient = false~ is included, then 'pn' is always omitted from
##   the resulting list of factors, even if it is different from 1. In this case, the resulting list
##   of factors will contain only univariate polynomials over power series with Puiseux series 
## 	 coefficients of positive degree in 'x'.
##-- By default (or if this behavior is requested explicitly by including the option
##   ~returnleadingcoefficient = automatic~), 'pn' is returned as a entry of the resulting
##   list of factors *only* if it is *not known* to be equal to 1, and omitted otherwise.
##ENDSUBSECTION
##INCLUDE remark_upop_factorizations.mi
##
##INCLUDE assignment_warning.mi
##
##EXAMPLES
##> with(MultivariatePowerSeries):
##- We create a univariate polynomial over power series from a list of power series:
##> f := UnivariatePolynomialOverPowerSeries(x^3 -x^2*y^2 -x*y^3 + y^4, x);
##<(verification="type") object
##- We compute its extended Hensel construction: 
##> F := ExtendedHenselConstruction(f); 
##<(verification="type") [object, object, object]
##- We can see more terms of the factors as follows:
##> map(print, map(Truncate, F, 5)):
##- Let us see that we got the correct output, i.e., that _f_ is equal to
##	the product of the terms in _F_ modulo the following ideal:
##> G := [seq(x^l*y^(6+(3-l)*4), l=0..3)];
##- Indeed,
##> g := mul(seq(Truncate(p), p in F)); 
##> r := evala(Normal(Truncate(f)-g));
##>	r := eval(r, y=y^3): r:=simplify(r, power, symbolic);
##> r := Groebner:-NormalForm(r, G, plex(x,y));
##< 0
##-	Notice that we use the command "eval" to evaluate _y=y^3_. This is just to be able
##	to use the command "Groebner:-NormalForm".
##- We can compare this output with respect to the "PuiseuxFactorize" command: 
##> F := PuiseuxFactorize(f,returnleadingcoefficient=false); 
##<(verification="type") [object, object, object, object]
##> map(print, map(Truncate, F, 5)):
##- As a second example, consider the following polynomial.
##> f := UnivariatePolynomialOverPowerSeries(x^5 + x^4*y - 2*x^3*y - 2*x^2*y^2 + x*(y^2 - y^3) + y^3, x);
##<(verification="type") object
##- We compute its extended Hensel construction: 
##> F := ExtendedHenselConstruction(f); 
##<(verification="type") [object, object, object, object, object]
##- We can obtain more terms of each factors:
##> map(print, map(Truncate, F, 5)):
##-	It is important to observe that in this particular example, the Newton polynomial of _f_ is
##> p := x^5-2*x^3*y+x*y^2;
##- After evaluating in _y=1_ and factorizing, we get:
##>	PolynomialTools:-Splits(eval(p, [y=1]), x)[2];
##- Hence, the initial factorization of _f_ contains only 3 factors (two of then have degree 2).
##	The "ExtendedHenselConstruction" algorithms takes care of these factors by making a recursive
##	call in each of them.
##-	Next, consider the following polynomial with power series coefficients in the variables
##	_y, z_.
##> f := UnivariatePolynomialOverPowerSeries(x^3 + (y - z + z^2)*x^2 - (y + z + y^2 - z^2)*x + (y^2 - z^3), x);
##<(verification="type") object
##- We compute its extended Hensel construction: 
##> F := ExtendedHenselConstruction(f, t); 
##<(verification="type") [object, object, object]
##- We can see more terms of the factors as follows:
##> map(print, map(Truncate, F, 5)):
##- Observe that the output are polynomials in the variable _x_ with power series in _t_ coefficients (_y(0)_ and 
##	(_z(0)_ are seemed as constants).
##
##SEEALSO
##- "UnivariatePolynomialOverPowerSeries"
##- "PuiseuxSeries"
##- "Inverse"
##- "HenselFactorize"
##- "PuiseuxFactorize"
##- "SetHenselBound"
##
##REFERENCES
##-(lead=indent) Parisa Alvandi, Massoud Ataei, Mahsa Kazemi, Marc Moreno Maza.
##  \"On the extended Hensel construction and its application to the computation of real limit points.\"
##	**J. of Symbolic Computation**, vol. **98**, p. 120-162, 2020.
##-(lead=indent) Sasaki, T., Kako, F.
##  \"Solving multivariate algebraic equation by Hensel construction.\"
##	**Jpn. J. Ind. Appl. Math**, vol. **2**, p. 257-285, 1999.
##-(lead=indent) Mohammadali Asadi, Alexander Brandt, Mahsa Kazemi, Marc Moreno Maza, and Erik Postma. 
## \"Multivariate Power Series in Maple.\" Corless R.M., Gerhard J., Kotsireas I.S. (eds) **Maple in Mathematics Education and Research. MC 2020.**
## **Communications in Computer and Information Science (CCIS)**, Vol. **1414** Springer (2021): 48-66.
##
##XREFMAP
##- UnivariatePolynomialOverPowerSeries : Help:MultivariatePowerSeries[UnivariatePolynomialOverPowerSeries]
##- PuiseuxSeries : Help:MultivariatePowerSeries[PuiseuxSeries]
##- Inverse : Help:MultivariatePowerSeries[Inverse]
##- "analytic expression" : Help:MultivariatePowerSeries[GetAnalyticExpression]
##- HenselFactorize : Help:MultivariatePowerSeries[HenselFactorize]
##- PuiseuxFactorize : Help:MultivariatePowerSeries[PuiseuxFactorize]
##- SetHenselBound : Help:MultivariatePowerSeries[SetHenselBound]
