##ENCODING ISO-8859-1
##PROCEDURE(testlimit=300, help,nospec,label="MultivariatePowerSeries/PuiseuxFactorize",versionnew="{ZONKEY}") MultivariatePowerSeries[PuiseuxFactorize]
##TITLE(halfline="factorize a univariate polynomial over power series with Puiseux series coefficients")
##    MultivariatePowerSeries[PuiseuxFactorize]
##ALIAS PuiseuxFactorize, MultivariatePowerSeries:-PuiseuxFactorize, MultivariatePowerSeries
##AUTHOR Matt Calder, Juan Gonzalez Trochez jgonza55@uwo.ca, Marc Moreno Maza moreno@csd.uwo.ca, Erik Postma
##
##CALLINGSEQUENCE
##- PuiseuxFactorize('u')
##- PuiseuxFactorize('u', 'pb', 'opt')
##
##PARAMETERS
##- 'u' : univariate polynomial over power series with Puiseux coefficients in one variable generated by this package
##- 'pb' : (optional) non-negative integer
##- opt : (optional) equation of the form `returnleadingcoefficient` = `optval`, where `optval` is `automatic`, `true`, or `false`
##
##DESCRIPTION
##- The command ~PuiseuxFactorize(u)~ factorizes 'u' over the field of Puiseux series
##  in one variable of the coefficients of 'u' and returns the factors as a list, 
##	or issues an error if this is not possible.
##- Let 'x' be the main variable of 'u'. The command ~PuiseuxFactorize(u)~ proceeds as follows.
##-- Firstly, Maple checks that the constant term, 'p0', of 'u' is nonzero. Maple verifies 
##	 if its "analytic expression" is known. If it is known to be different than 0,
##	 then the command proceeds without modifying 'u'. In the case it is equal to 0, then we
##	 factorize 'x' to the power 'm', with 'm' being the degree of 
##	 the smallest nonzero term of 'u'.
##	 If its "analytic expression" is not known, then Maple makes use of a bound 'b' to
##	 check if 'a0' is zero up to that degree or not. If by truncating 'a0' up to 'b' Maple finds that is nonzero, then it does not
##	 modify 'u'. If this is not the case, then an error is returned. In this case, one may want to rerun the command with a higher bound 'b' (see below). 
##-- Secondly, let 'pn' be the leading coefficient of 'u' (the Puiseux series that is the
##   coefficient of the highest power, 'n', of 'x'). Maple verifies if its "analytic
##   expression" is known. If it is not known, or known to be different from 1, then 'u' is multiplied
##   by the inverse of 'pn'; let us call the result 'v'. Otherwise (if 'pn' is known to be equal to
##   1), 'v' is defined to be equal to 'u'. Note that computing the inverse 
##	 of a Puiseux series may fail (see "Inverse"). See also the discussion of the
##   `returnleadingcoefficient` option below.
##-- Thirdly, let 'pn1' be the coefficient of degree 'n-1' of 'u'. The 
##	 command ~TschirnhausenTransformation(v, pn1)~ is evaluated; let us call the 
##	 result 'w'. The goal of this algorithm is to make the term of degree 'n-1'
##	 equal to zero. 
##-- Next, an appropriate change of variables is applied to 'w' in order to make it 
##	 a univariate polynomial over power series. This allow us to apply the 
##	 ~HenselFactorize~ algorithm. After that, Maple reverts the changes of variables
##	 previously applied. For details, see Nowak's version of the
##	 Newton-Puiseux algorithm.  
##-- Then, if the `returnleadingcoefficient` option instructs it to do so (see below), 
##	 Maple adds the coefficient 'pn' to the list containing the output of ~HenselFactorize~.
##-- Finally, Maple adds 'm' copies of the main variable 'u' to the output list.
##- If the argument 'pb' is given, its value is used for the bound 'b'. 
##  Otherwise, the global default for bound 'b' is used; 
##	this can be set using `SetPuiseuxBound`. Its 
##	default value is 10. 
##- Since it is really 'v' that is factored in the second and third steps of the algorithm below,
##  and 'v' and 'u' differ by a factor of 'pn' (the leading coefficient of 'u'), it is necessary to
##  include a factor corresponding to 'pn' in order to obtain factors that multiply together to
##  'u'. The `returnleadingcoefficient` option determines whether 'pn', investigated and potentially
##  used in the first step of the algorithm, is returned with the other factors. In all cases, if
##  'pn' is returned, it is converted to a univariate polynomial over power series with
##  main variable 'x' in order to match the type of the other factors; out of necessity, it is a
##  constant polynomial, because it does not depend on 'x' (it is, after all, a
##  coefficient of 'x').
##-- If the option ~returnleadingcoefficient = true~ is included, then 'pn' is always returned as
##   the first entry in the resulting list of factors, even if it is equal to 1.
##-- If the option ~returnleadingcoefficient = false~ is included, then 'pn' is always omitted from
##   the resulting list of factors, even if it is different from 1. In this case, the resulting list
##   of factors will contain only univariate polynomials over power series with Puiseux series 
## 	 coefficients of positive degree in 'x'.
##-- By default (or if this behavior is requested explicitly by including the option
##   ~returnleadingcoefficient = automatic~), 'pn' is returned as a entry of the resulting
##   list of factors *only* if it is *not known* to be equal to 1, and omitted otherwise.
##INCLUDE remark_upop_factorizations.mi
##
##INCLUDE assignment_warning.mi
##
##EXAMPLES
##> with(MultivariatePowerSeries):
##- We create a univariate polynomial over power series from a list of Puiseux series:
##> f := UnivariatePolynomialOverPuiseuxSeries([PuiseuxSeries(1), PuiseuxSeries(0), PuiseuxSeries(x, [x=x^(1/3)]), PuiseuxSeries(x, [x=x^(1/2)]), PuiseuxSeries(x/(1+x), [x=x^(1/2)])], z);
##<(verification="type") object
##- We compute its Puiseux factorization: 
##> F := PuiseuxFactorize(f); 
##<(verification="type") [object, object, object, object, object, object]
##- We can see more terms of the factors as follows:
##> map(print, map(Truncate, F, 10)):
##- Notice that by using the special option ~returnleadingcoefficient = true~,
## 	we get an different factor than one.
##> F := PuiseuxFactorize(f, returnleadingcoefficient = true); 
##<(verification="type") [object, object, object, object, object, object]
##> map(print, map(Truncate, F, 10)):
##- Let us see that we got the correct output.
##> p := Multiply(seq(F));
##> Truncate(Subtract(f, p), 10);
##< 0
##- Now by using ~returnleadingcoefficient = false~,
## 	we get only 5 factors.
##> F := PuiseuxFactorize(f, returnleadingcoefficient = false); 
##<(verification="type") [object, object, object, object, object]
##> map(print, map(Truncate, F,10)):
##- Let's now define 4 Puiseux series and a univariate polynomial
##	using this series as coefficients.
##> a1 := PuiseuxSeries(1 + y^2, [y=y^(1/2)], [y=-2]); a2 := PuiseuxSeries(1/(y^2+1), [y=y^(1/6)], [y=-1]); a3 := PuiseuxSeries(1/(y^2+y+1), [y=y^(1/2)], [y=-2]);
##> bproc := proc(d) if d  = 20 then return u^(20); else return 0; end if; end proc; 
##> pso := PowerSeries(bproc, variables={u}); a0 := PuiseuxSeries(pso, [u=y]);
##> h := UnivariatePolynomialOverPuiseuxSeries([PuiseuxSeries(0), PuiseuxSeries(0),a0,a2,a3], 'x');
##- Now let's try to factorize 'h'.
##> F := PuiseuxFactorize(h); 
##<(verification="testerror") "invalid"
##- We get an error since Maple is not able to determine if 'a0' is nonzero
##	or not. Let's try again but now with a bound of 21.
##> F := PuiseuxFactorize(h, 21);
##<(verification="type") [object, object, object, object, object, object]
##- Notice that the univariate polynomial over power series 'x' is returned
## 	twice at the beginning of the output. This is due the fact that 'x^2'
##	had to be factored out of 'h' at the first step of the algorithm. 
##
##SEEALSO
##- "UnivariatePolynomialOverPowerSeries"
##- "PuiseuxSeries"
##- "Inverse"
##- "HenselFactorize"
##- "ExtendedHenselConstruction"
##- "SetPuiseuxBound"
##- "Subtract"
##- "TschirnhausenTransformation"
##
##REFERENCES
##-(lead=indent) K. J. Nowak.
##  \"Some elementary proofs of Puiseux's theorems.\"
##  **Univ. Iagel. Acta Math** Vol. **38** (2000): 279-282.
##-(lead=indent) Mohammadali Asadi, Alexander Brandt, Mahsa Kazemi, Marc Moreno Maza, and Erik Postma. 
## \"Multivariate Power Series in Maple.\" Corless R.M., Gerhard J., Kotsireas I.S. (eds) **Maple in Mathematics Education and Research. MC 2020.**
## **Communications in Computer and Information Science (CCIS)**, Vol. **1414** Springer (2021): 48-66.
##
##XREFMAP
##- UnivariatePolynomialOverPowerSeries : Help:MultivariatePowerSeries[UnivariatePolynomialOverPowerSeries]
##- PuiseuxSeries : Help:MultivariatePowerSeries[PuiseuxSeries]
##- Inverse : Help:MultivariatePowerSeries[Inverse]
##- "analytic expression" : Help:MultivariatePowerSeries[GetAnalyticExpression]
##- HenselFactorize : Help:MultivariatePowerSeries[HenselFactorize]
##- ExtendedHenselConstruction : Help:MultivariatePowerSeries[ExtendedHenselConstruction]
##- SetPuiseuxBound : Help:MultivariatePowerSeries[SetPuiseuxBound]
##- Subtract : Help:MultivariatePowerSeries[Subtract]
##- TschirnhausenTransformation : Help:MultivariatePowerSeries[TschirnhausenTransformation]
