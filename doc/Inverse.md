##ENCODING ISO-8859-1
##PROCEDURE(help,nospec,label="MultivariatePowerSeries/Inverse",versionnew="{XENOMORPH}", versionupdated="{ZONKEY}") MultivariatePowerSeries[Inverse]
##TITLE(halfline="compute the inverse of a power series or Puiseux series")
##    MultivariatePowerSeries[Inverse]
##ALIAS Inverse, MultivariatePowerSeries:-Inverse, MultivariatePowerSeries
##AUTHOR Ali Asadi masadi4@uwo.ca, Alex Brandt abrandt5@uwo.ca, Marc Moreno Maza moreno@csd.uwo.ca
##
##CALLINGSEQUENCE
##- 1/'p'
##- Inverse('p')
##- Inverse('s', 'nonzero_pso_bound', 'smallest_term_bound')
##
##PARAMETERS
##- 'p' : power series generated by this package
##-(versionnew="{ZONKEY}") 's' : Puiseux series generated by this package
##- 'nonzero_pso_bound' : (optional) non-negative integer
##-	'smallest_term_bound' : (optional) non-negative integer
##
##DESCRIPTION
##- The commands ~1/p~ and ~Inverse(p)~ compute the multiplicative inverse of the power series
##  'p'. This requires that 'p' is invertible, that is, that 'p' has a nonzero constant term; if
##  that is not the case, an error is thrown.
##- The calling sequence ~Inverse('s', 'nonzero_pso_bound', 'smallest_term_bound')~ computes the multiplicative 
##	inverse of the Puiseux series 's', whenever this is possible. 
##	This depends of a few different things, which are verified in the following
##	order:
##--	First, if the power series used to create 's' is invertible, then we compute 
##	the inverse of 's' by computing the inverse of its internal power series.
##--	Second, if the power series used to generate 's' has a rational analytic 
##	expression, then we can always compute the inverse of 's', by algebraic 
##	manipulations. 
##--	Third, if the power series used to create 's' has an analytic expression 
##	that is not rational, then there are two cases, either the set of rays
##	used to create 's' contain at least a ray of weight zero (the sum of its 
##	components is equal to zero) or it does not. 
##--	In both cases, we start by looking for the first nonzero monomial in
##	the internal power series of 's'. This process is done by examining all 
##	monomials in the internal power series with total degree less than or 
##	equal to some bound 'b'. If no monomial different from zero is found, 
##	the command will fail. 
##--(versionnew="{ZONKEY}",name=nonzero_pso_bound)	If the argument 'nonzero_pso_bound' is given, its value is used for 'b'. 
##  Otherwise, the global default for the power series degree bound is used; 
##	this can be set using `SetNonzeroPowerSeriesDegreeBound`, and its 
##	default value is 10. 
##-(versionnew="{ZONKEY}",name=smallest_term_bound)	If we have at least a ray of weight zero, then we cannot guarantee that the inverse has been
##	found. We try to look for the grevlex minimum element of the support of _s_, that is,
##	the grevlex minimum element between the exponents of all nonzero monomials of _s_.
##	Having at least a ray of weight zero makes this process not always possible. So, we have an
##	internal bound and we try to look for this minimum between all the monomials such 
##	that the absolute value of their total degree is less or equal than this bound. 
##	Unfortunately, this process may fail, and the only way of knowing that 
##	it has failed is by using the `Truncate` command to ask for more terms. In this cases, 
##	we can use the extra option 'smallest_term_bound' to run the command with
##	a higher internal bound.
##--	If the argument 'smallest_term_bound' is given, its value is used for 'b'. 
##  Otherwise, the global default for the power series degree bound is used; 
##	this can be set using `SetSmallestPowerSeriesDegreeBound`, and its 
##	default value is 10. 
##
##INCLUDE assignment_warning.mi
##
##EXAMPLES
##> with(MultivariatePowerSeries):
##- We define a power series, _a_, representing a polynomial.
##> a := PowerSeries(1-x-y);
##<(verification="type") object
##- We can define its inverse in two equivalent ways:
##> b := 1/a;
##<(verification="type") object
##> c := Inverse(a);
##<(verification="type") object
##- We verify that the two definitions are equal, at least for the terms up to homogeneous degree
##  10.
##> Truncate(b - c, 10);
##< 0
##- A different power series represents the sine of _x_.
##> sx := PowerSeries(d -> ifelse(d :: odd, (-1)^((d-1)/2) * x^d/d!, 0), analytic = sin(x));
##<(verification="type") object
##- Because the constant coefficient of _sx_ is zero, we cannot invert it. (Its multiplicative
##  inverse is a Laurent series, not a power series.)
##> 1/sx;
##<(verification="testerror") "not invertible"
##-	We create a Puiseux series 's1'.
##> q := u/(u + v + w +u^2*w); 
##	mp := [u=x^(1/4), v=x^(3)*y^(2), w=x^(1/2)*y^(-1/4)]; e := [x=3, y=-2];
##> s1 := PuiseuxSeries(q, mp, e);
##<(verification="type") object
##-	We create a Puiseux series 's2'.
##> bproc1 := proc(d) 
##	if d = 13 then
##		return u^(12)*v + u*v^(12);
##	elif d = 14 then
##		return u^(14);
##	else 
##		return 0;
##	end if; 
##	end proc;  
##>	g := PowerSeries(bproc1, variables={u,v});
##	X := [x, y]; U := [u, v]; R := [[1,-1], [1,1]];
##>	s2 := PuiseuxSeries(g, X, U, R);
##<(verification="type") object
##-	We create a Puiseux series 's3'.
##> bproc2 := proc(d) 
##	if d = 1 then
##		return u^1;
##	elif d = 2 then
##		return u^2;
##	elif d = 3 then
##		return u^3;
##	elif d = 25 then
##		return v^25;
##	else 
##		return 0;
##	end if; 
##	end proc;  
##>	g := PowerSeries(bproc2, variables={u,v});
##	X := [x, y]; U := [u, v]; R := [[1,0], [1,-1]];
##>	s3 := PuiseuxSeries(g, X, U, R);
##<(verification="type") object
##-	We invert _s1_ and check its indeed its inverse.
##> s4 := Inverse(s1);
##<(verification="type") object
##> m := Multiply(s1, s4);
##<(verification="type") object
##> Truncate(m, 40);
##-	We try to invert _s2_ and check if the inverse was found.
##> s5 := Inverse(s2);
##<(verification="testerror") 
##> s5 := Inverse(s2, 14);
##<(verification="type") object
##> m := Multiply(s2, s5);
##<(verification="type") object
##> Truncate(m, 40);
##-	We try to invert _s3_ and check if the inverse was found.
##> s6 := Inverse(s3);
##<(verification="type") object
##> Truncate(s6, 40);
##<(verification="testerror") 
##> s6 := Inverse(s3, 10, 25);
##<(verification="type") object
##> m := Multiply(s3, s6);
##<(verification="type") object
##> Truncate(m, 40);
##
##SEEALSO
##- "PowerSeries"
##- "PuiseuxSeries"
##- "GeometricSeries"
##- "Divide"
##- "Inverse"
##- "IsUnit"
##- "ApproximatelyEqual"
##- "GetAnalyticExpression"
##-	"SetNonzeroPowerSeriesDegreeBound"
##-	"SetSmallestPowerSeriesDegreeBound"
##- "Truncate"
##
##XREFMAP
##- PowerSeries : Help:MultivariatePowerSeries[PowerSeries] 
##- PuiseuxSeries : Help:MultivariatePowerSeries[PuiseuxSeries]
##- GeometricSeries : Help:MultivariatePowerSeries[GeometricSeries] 
##- Divide : Help:MultivariatePowerSeries[Divide]
##- Inverse : Help:MultivariatePowerSeries[Inverse]
##- IsUnit : Help:MultivariatePowerSeries[IsUnit]
##- ApproximatelyEqual : Help:MultivariatePowerSeries[ApproximatelyEqual]
##- GetAnalyticExpression : Help:MultivariatePowerSeries[GetAnalyticExpression]
##- SetNonzeroPowerSeriesDegreeBound : Help:MultivariatePowerSeries[SetNonzeroPowerSeriesDegreeBound]
##- SetSmallestPowerSeriesDegreeBound : Help:MultivariatePowerSeries[SetSmallestPowerSeriesDegreeBound]
##- Truncate : Help:MultivariatePowerSeries[Truncate]
