##ENCODING ISO-8859-1
##PROCEDURE(help,nospec,label="MultivariatePowerSeries/Inverse",versionnew="{XENOMORPH}", versionupdated="{ZONKEY}") MultivariatePowerSeries[Inverse]
##TITLE(halfline="compute the inverse of a power series or Puiseux series")
##    MultivariatePowerSeries[Inverse]
##ALIAS Inverse, MultivariatePowerSeries:-Inverse, MultivariatePowerSeries
##AUTHOR Ali Asadi masadi4@uwo.ca, Alex Brandt abrandt5@uwo.ca, Marc Moreno Maza moreno@csd.uwo.ca
##
##CALLINGSEQUENCE
##- 1/'p'
##- Inverse('p')
##- Inverse('s', 'nonzero_pso_bound', 'smallest_term_bound')
##
##PARAMETERS
##- 'p' : power series generated by this package
##-(versionnew="{ZONKEY}") 's' : Puiseux series generated by this package
##-(versionnew="{ZONKEY}") 'nonzero_pso_bound' : (optional) non-negative integer
##-(versionnew="{ZONKEY}") 'smallest_term_bound' : (optional) non-negative integer
##
##DESCRIPTION
##- The commands ~1/p~ and ~Inverse(p)~ compute the multiplicative inverse of the power series
##  'p'. This requires that 'p' is invertible, that is, that 'p' has a nonzero constant term; if
##  that is not the case, an error is signaled.
##- The calling sequence ~Inverse('s', 'nonzero_pso_bound', 'smallest_term_bound')~ computes the multiplicative 
##	inverse of the Puiseux series 's', whenever this is possible. To explain the algorithm used, we
##	first need to review some basic information on Puiseux series.
##INCLUDE PuiseuxSeriesIntro.mi
##- The algorithm used depends of a few different things, which are verified in the following
##	order:
##--	First, if the power series used to create 's' is invertible, then we compute 
##	the inverse of 's' by computing the inverse of its internal power series.
##--	Second, if the power series used to generate 's' has a rational function as its analytic 
##	expression, then we compute the inverse of 's' by algebraic 
##	manipulations. 
##--	Otherwise, we start by looking for the first nonzero monomial in
##	the internal power series of 's'. This process is done by examining all 
##	monomials in the internal power series with total degree less than or 
##	equal to some bound 'b'. If no monomial different from zero is found, 
##	the command will fail. 
##--(versionnew="{ZONKEY}",name=nonzero_pso_bound) If the argument 'nonzero_pso_bound' is given, its
##  value is used for 'b'. Otherwise, if "SetNonzeroPowerSeriesDegreeBound" has been called on 's',
##  its value is used. Otherwise, the global value for this bound is used; this can also be set
##	using "SetNonzeroPowerSeriesDegreeBound", and its default value is 10.
##- If we have at least a ray of weight zero, then
##	we cannot guarantee that the inverse has been found. In order to compute the inverse correctly,
##	we *must* find the grevlex minimum element of the support of 's', that is, the grevlex minimum
##	element between the exponents of all nonzero monomials of 's'. Having at least a ray of weight
##	zero makes this process not always possible. So, we use some bound 'd' and we find the minimum
##	among the monomials *of the internal power series* that are at most 'd' greater than the first
##	nonzero monomial found. Unfortunately, it is possible that one might need to look for
##	arbitrarily high degrees in the internal power series to find the monomial that is truly the
##	grevlex smallest in the Puiseux series. In cases where we cannot prove that the term we find is
##	the smallest, Maple generates an error message if subsequent examination of higher degree terms
##	results in finding a smaller monomial. In this case, one can rerun the computation with a higher
##	value for 'd'.
##--(versionnew="{ZONKEY}",name=smallest_term_bound) If the argument 'smallest_term_bound' is given,
##  its value is used for 'd'. Otherwise, if "SetSmallestTermDegreeBound" has been called on
##  's', its value is used. Otherwise, the global value for this bound is used; this can also be set
##  using "SetSmallestTermDegreeBound", and its default value is 10.
##
##INCLUDE assignment_warning.mi
##
##EXAMPLES
##> with(MultivariatePowerSeries):
##- We define a power series, _a_, representing a polynomial.
##> a := PowerSeries(1-x-y);
##<(verification="type") object
##- We can define its inverse in two equivalent ways:
##> b := 1/a;
##<(verification="type") object
##> c := Inverse(a);
##<(verification="type") object
##- We verify that the two definitions are equal, at least for the terms up to homogeneous degree
##  10.
##> Truncate(b - c, 10);
##< 0
##- A different power series represents the sine of _x_.
##> sx := PowerSeries(d -> ifelse(d :: odd, (-1)^((d-1)/2) * x^d/d!, 0), analytic = sin(x));
##<(verification="type") object
##- Because the constant coefficient of _sx_ is zero, we cannot invert it. (Its multiplicative
##  inverse is a Laurent series, not a power series.)
##> 1/sx;
##<(verification="testerror") "not invertible"
##-	We create a Puiseux series 's1'.
##> q := u/(u + v + w +u^2*w); 
##	mp := [u=x^(1/4), v=x^(3)*y^(2), w=x^(1/2)*y^(-1/4)]; e := [x=3, y=-2];
##> s1 := PuiseuxSeries(q, mp, e);
##<(verification="type") object
##-	We create a Puiseux series 's2'.
##> bproc1 := proc(d) 
##	if d = 13 then
##		return u^(12)*v + u*v^(12);
##	elif d = 14 then
##		return u^(14);
##	else 
##		return 0;
##	end if; 
##	end proc;  
##>	g := PowerSeries(bproc1, variables={u,v});
##	X := [x, y]; U := [u, v]; R := [[1,-1], [1,1]];
##>	s2 := PuiseuxSeries(g, X, U, R);
##<(verification="type") object
##-	We create a Puiseux series 's3'.
##> bproc2 := proc(d) 
##	if d = 1 then
##		return u^1;
##	elif d = 2 then
##		return u^2;
##	elif d = 3 then
##		return u^3;
##	elif d = 25 then
##		return v^25;
##	else 
##		return 0;
##	end if; 
##	end proc;  
##>	g := PowerSeries(bproc2, variables={u,v});
##	X := [x, y]; U := [u, v]; R := [[1,0], [1,-1]];
##>	s3 := PuiseuxSeries(g, X, U, R);
##<(verification="type") object
##-	We invert _s1_ and check its indeed its inverse.
##> s4 := Inverse(s1);
##<(verification="type") object
##> m := Multiply(s1, s4);
##<(verification="type") object
##> Truncate(m, 40);
##-	We try to invert _s2_ and check if the inverse was found.
##> s5 := Inverse(s2);
##<(verification="testerror") 
##> s5 := Inverse(s2, 14);
##<(verification="type") object
##> m := Multiply(s2, s5);
##<(verification="type") object
##> Truncate(m, 40);
##-	We try to invert _s3_ and check if the inverse was found.
##> s6 := Inverse(s3);
##<(verification="type") object
##> Truncate(s6, 40);
##<(verification="testerror") 
##> s6 := Inverse(s3, 10, 25);
##<(verification="type") object
##> m := Multiply(s3, s6);
##<(verification="type") object
##> Truncate(m, 40);
##
##SEEALSO
##- "PowerSeries"
##- "PuiseuxSeries"
##- "GeometricSeries"
##- "Divide"
##- "Inverse"
##- "IsUnit"
##- "ApproximatelyEqual"
##- "GetAnalyticExpression"
##-	"SetNonzeroPowerSeriesDegreeBound"
##-	"SetSmallestTermDegreeBound"
##- "Truncate"
##
##INCLUDE PxRef.mi
##
##XREFMAP
##- PowerSeries : Help:MultivariatePowerSeries[PowerSeries] 
##- PuiseuxSeries : Help:MultivariatePowerSeries[PuiseuxSeries]
##- GeometricSeries : Help:MultivariatePowerSeries[GeometricSeries] 
##- Divide : Help:MultivariatePowerSeries[Divide]
##- Inverse : Help:MultivariatePowerSeries[Inverse]
##- IsUnit : Help:MultivariatePowerSeries[IsUnit]
##- ApproximatelyEqual : Help:MultivariatePowerSeries[ApproximatelyEqual]
##- GetAnalyticExpression : Help:MultivariatePowerSeries[GetAnalyticExpression]
##- SetNonzeroPowerSeriesDegreeBound : Help:MultivariatePowerSeries[SetNonzeroPowerSeriesDegreeBound]
##- SetSmallestTermDegreeBound : Help:MultivariatePowerSeries[SetNonzeroPowerSeriesDegreeBound]
##- Truncate : Help:MultivariatePowerSeries[Truncate]
